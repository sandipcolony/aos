//Assignment No-8 Write a C program which receives file names as command line
//arguments and display those filenames in ascending order according to their
//sizes. I) (e.g $ a.out a.txt b.txt c.txt, â€¦)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

// Define a structure to hold file information
struct FileInfo 
{
  char* name;
  off_t size;
};

// Comparison function for sorting FileInfo structures by size
int compareFileInfo(const void* a, const void* b) 
{
  return ((struct FileInfo*)a)->size - ((struct FileInfo*)b)->size;
}


int main(int argc, char* argv[]) 
{
  // Check if the user provided at least one file name
  if (argc < 2) 
  {
    fprintf(stderr,"Usage: %s <file1> <file2> ... <fileN>;\n", argv[0]);
    return 1;
  }

  // Create an array of FileInfo structures to hold file information
  struct FileInfo* fileInfos = malloc((argc - 1) * sizeof(struct FileInfo));

  if (fileInfos == NULL)
  {
    perror("Memory allocation failed");
    return 1;
  }

  // Obtain file sizes and store file information
  for (int i = 1; i <argc; i++) 
  {
    struct stat fileStat;

    if (stat(argv[i], &fileStat) == 0)
    {
      fileInfos[i - 1].name = strdup(argv[i]);
      fileInfos[i - 1].size = fileStat.st_size;
    } 
    else
    {
      perror("stat");
      return 1;
    }
  }

  // Sort the fileInfos array based on file size
  qsort(fileInfos, argc - 1, sizeof(struct FileInfo), compareFileInfo);

  // Display the sorted file names
  for (int i = 0; i < argc - 1; i++) 
  {
    printf("%s: %ld bytes\n", fileInfos[i].name, (long)fileInfos[i].size);
    free(fileInfos[i].name);
  }
/*Assignment No-24 Write a C program that print the exit status of a terminated child process.

In Unix-like operating systems, you can use the wait or waitpid system calls to retrieve the exit status of
a terminated child process. Here&#39;s a C program that demonstrates how to print the exit status of a
terminated child process:*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/wait.h>

int main() {
pid_t child_pid;
int status;

// Create a child process
child_pid = fork();

if (child_pid == -1) {
perror("fork");
exit(EXIT_FAILURE);
}

if (child_pid == 0) {
// Child process
printf("Child process (PID %d) is running.\n", getpid());
// Simulate some work in the child process
sleep(2);
printf("Child process (PID %d) is exiting.\n", getpid());
exit(42); // Exit with status 42
} else {
// Parent process
printf("Parent process (PID %d) is waiting for the child to terminate.\n", getpid());

// Wait for the child to terminate and retrieve its exit status
if (wait(&status) == -1) {
perror("wait");
exit(EXIT_FAILURE);
}

if (WIFEXITED(status)) {
// Child exited normally
int exit_status = WEXITSTATUS(status);
printf("Child process (PID %d) exited with status: %d\n", child_pid, exit_status);
} else if (WIFSIGNALED(status)) {
// Child was terminated by a signal
int term_signal = WTERMSIG(status);
printf("Child process (PID %d) was terminated by signal: %d\n", child_pid, term_signal);
}
}

return 0;
}

  // Free allocated memory
  free(fileInfos);

  return 0;
}
b.